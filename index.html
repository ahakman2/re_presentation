<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* {box-sizing: border-box}
body {font-family: Verdana, sans-serif; margin:0; background: #132020;}

a:link {
  color: #04AA6d;
}

a:visited {
  color: #00bfff;
}

p.top {
  margin-top: 0px;
}

/*contains the slide-index container at the top, and the narration div at the bottom*/
/* at 4k, viewport is 1600 x 790
   at 1080 viewport is
*/
.overall-container {
  position: fixed;
  height: 100vh;
  width: 100vw;
  display: grid;
  grid-template-columns: 1fr 4fr;
  grid-template-rows: auto 1fr;
  gap: 10px;
}

/* Slideshow container */
.slideshow-container {
  position: relative;
  display: block;
  background: #132020;
}

.index-wrapper {
    height: 0;
    min-height: 100%;
}

/* The index container */
.index-container {
    padding: 5px 10px;
    height:99%;
    background: #132020;
    display: block;
    overflow: auto;
}

/* The index entries */
.myIndex {
  margin: 0 2px;
  display: block;
  color: white;
}

/* Add a background color to the active index */
.myIndex.active {
  background-color: #04AA6d;
}

.myIndex:hover {
  background-color: rgba(179,179,179,0.8);
}

.notes-container {
  padding: 0px 10px 10px 10px;
  grid-column: 1 / 3;
  background: #132020;
  color: white;
  overflow: auto;
}

/* Slides */
.mySlides {
  display: none;
  padding: 0px;
  text-align: center;
}

/* Notes */
.myNotes {
  display: none;
  padding: 0px;
  text-align: left;
}

/* Next & previous buttons */
.prev, .next {
  cursor: pointer;
  position: absolute;
  top: 50%;
  width: auto;
  margin-top: -30px;
  padding: 16px;
  color: #888;
  font-weight: bold;
  font-size: 20px;
  border-radius: 0 3px 3px 0;
  user-select: none;
}

/* Position the "next button" to the right */
.next {
  position: absolute;
  right: 0;
  border-radius: 3px 0 0 3px;
}

/* On hover, add a black background color with a little bit see-through */
.prev:hover, .next:hover {
  background-color: rgba(179,179,179,0.8);
  color: white;
}

</style>
</head>
<body>
<div class="overall-container">
<div class="index-wrapper">
<div class="index-container">
  <span class="myIndex" onclick="currentSlide(1)">Title</span> 
  <span class="myIndex" onclick="currentSlide(2)">Background - The Machine</span> 
  <span class="myIndex" onclick="currentSlide(3)">Repairs - Spindle LV PS</span> 
  <span class="myIndex" onclick="currentSlide(4)">Repairs - Shorted IGBT</span>
  <span class="myIndex" onclick="currentSlide(5)">Repairs - Phase Detection</span>
  <span class="myIndex" onclick="currentSlide(6)">Repairs - "Phase Fooler"</span>
  <span class="myIndex" onclick="currentSlide(7)">Motivation - Probing</span>
  <span class="myIndex" onclick="currentSlide(8)">Goal - Add More Memory</span>
  <span class="myIndex" onclick="currentSlide(9)">Firmware Limitation</span>
  <span class="myIndex" onclick="currentSlide(10)">RE.0 Logic Analyzer</span>
  <span class="myIndex" onclick="currentSlide(11)">RE.0 LA Repair</span>
  <span class="myIndex" onclick="currentSlide(12)">RE.1 Testbench / Probing</span>
  <span class="myIndex" onclick="currentSlide(13)">RE.2 Extract Firmware</span>
  <span class="myIndex" onclick="currentSlide(14)">RE.2 Interleave Firmware</span>
  <span class="myIndex" onclick="currentSlide(15)">RE.3 Boot Sequence</span>
  <span class="myIndex" onclick="currentSlide(16)">RE.3 CPU Card Overview</span>
  <span class="myIndex" onclick="currentSlide(17)">RE.3 CPU Onboard Memory</span>
  <span class="myIndex" onclick="currentSlide(18)">RE.3 Memory Map</span>
  <span class="myIndex" onclick="currentSlide(19)">RE.3 Ghidra Overview</span>
  <span class="myIndex" onclick="currentSlide(20)">RE.3 Boot Sequence Analysis</span>
  <span class="myIndex" onclick="currentSlide(21)">RE.4 Dip Switch Reset</span>
  <span class="myIndex" onclick="currentSlide(22)">RE.5 Display Scaler</span>
  <span class="myIndex" onclick="currentSlide(23)">RE.5 Keyboard</span>
  <span class="myIndex" onclick="currentSlide(24)">RE.6 Track 'prosiz'</span>
  <span class="myIndex" onclick="currentSlide(25)">RE.6 Format Analysis</span>
  <span class="myIndex" onclick="currentSlide(26)">RE.6 AH HA! EUREKA!!</span>
  <span class="myIndex" onclick="currentSlide(27)">RE.6 Testing the FIX</span>
  <span class="myIndex" onclick="currentSlide(28)">RE.7 Not ALL the memory?</span>
  <span class="myIndex" onclick="currentSlide(29)">RE.7 Memory Boards</span>
  <span class="myIndex" onclick="currentSlide(30)">RE.7 'prosiz' 5 Analysis</span>
  <span class="myIndex" onclick="currentSlide(31)">RE.7 That's Odd</span>
  <span class="myIndex" onclick="currentSlide(32)">RE.7 What the?</span>
  <span class="myIndex" onclick="currentSlide(33)">RE.7 Paper Tape &amp; Marketing!</span>
  <span class="myIndex" onclick="currentSlide(34)">RE.7 Some Adjustments</span>
  <span class="myIndex" onclick="currentSlide(35)">RE.7 SUCCESS!!!</span>
  <span class="myIndex" onclick="currentSlide(36)">RE.8 New Hardware</span>
  <span class="myIndex" onclick="currentSlide(37)">RE.8 Hardware Upgrade 2</span>
  <span class="myIndex" onclick="currentSlide(38)">RE.9 Summary of all changes</span>
  <span class="myIndex" onclick="currentSlide(39)">RE.10 Future Hardware Upgrade</span>
  <span class="myIndex" onclick="currentSlide(40)">Summary</span>
  <span class="myIndex" onclick="currentSlide(41)">Bonus Slides</span>
  <span class="myIndex" onclick="currentSlide(42)">Why a CNC machine?</span>
  <span class="myIndex" onclick="currentSlide(43)">Dirty machine covered in graphite</span>
  <span class="myIndex" onclick="currentSlide(44)">Dirty machine covered in graphite</span>
  <span class="myIndex" onclick="currentSlide(45)">Spindle motor bearing replacement</span>
  <span class="myIndex" onclick="currentSlide(46)">Spindle motor bearing replacement</span>
  <span class="myIndex" onclick="currentSlide(47)">Cleaning toolchanger</span>
  <span class="myIndex" onclick="currentSlide(48)">Cleaning under y-axis way covers</span>
  <span class="myIndex" onclick="currentSlide(49)">Plugged oil passages</span>
  <span class="myIndex" onclick="currentSlide(50)">Y-axis chip build up</span>
  <span class="myIndex" onclick="currentSlide(51)">Saddle removed and cleaned</span>
  <span class="myIndex" onclick="currentSlide(52)">Turcite replacement on saddle</span>
  <span class="myIndex" onclick="currentSlide(53)">Further disassembly / moving</span>
  <span class="myIndex" onclick="currentSlide(54)">Z-axis servo reinstalled</span>
  <span class="myIndex" onclick="currentSlide(55)">Removal and cleaning head casting</span>
  <span class="myIndex" onclick="currentSlide(56)">Reinstall head casting</span>
  <span class="myIndex" onclick="currentSlide(57)">A Lathe has joined the team!</span>
  <span class="myIndex" onclick="currentSlide(58)">Lathe spindle drive repair</span>
  <span class="myIndex" onclick="currentSlide(59)">Lathe 3-phase shenanigans</span>
  <span class="myIndex" onclick="currentSlide(60)">Lathe 3-phase shenanigans</span>
  <span class="myIndex" onclick="currentSlide(61)">Lathe hydraulic repairs / first parts</span>
  <span class="myIndex" onclick="currentSlide(62)">Lathe spindle braking</span>
  <span class="myIndex" onclick="currentSlide(63)">Another machine! Wire EDM</span>
</div>
</div>

<div class="slideshow-container">
<div class="mySlides">
  <object id="slide01" data="slides/slide01.svg" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide02" data="slides/slide02.svg" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide03" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide04" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide05" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide06" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide07" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide08" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide09" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide10" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide11" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide12" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide13" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide14" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide15" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide16" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide17" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide18" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide19" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide20" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide21" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide22" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide23" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide24" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide25" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide26" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide27" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide28" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide29" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide30" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide31" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide32" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide33" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide34" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide35" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide36" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide37" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide38" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide39" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide40" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide41" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide42" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide43" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide44" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide45" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide46" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide47" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide48" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide49" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide50" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide51" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide52" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide53" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide54" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide55" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide56" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide57" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide58" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide59" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide60" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide61" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide62" type="image/svg+xml"></object>
</div>
<div class="mySlides">
  <object id="slide63" type="image/svg+xml"></object>
</div>

<a class="prev" onclick="plusSlides(-1)">❮</a>
<a class="next" onclick="plusSlides(1)">❯</a>

</div>

<div class="notes-container" id="notes-container">
<div class="myNotes">
    <p class="top">You can navigate the presentation by clicking the previous / next buttons in the slide window, clicking on any of the slide titles in the index window on the left, or by using the keyboard.</p>
    <p>Fullscreen [F11] reccomended for more vertical height.  Keyboard navigation: [LEFT]/[RIGHT] Previous / Next slide   [UP]/[DOWN] Scroll this Notes / "Dialog" area</p>
</div>
<div class="myNotes">
    <p class="top">First, a few slides of background to understand the motivation for the project before I get to the actual reverse engineering.</p>
    <p>A few years ago, I bought a 3-axis vertical machining center.  It was very heavy, almost 12,000 lb, and very big, almost too big for a two car garage as it takes up a lot of floor space. It's hard to tell from the photo above, but it was also very dirty as the previous owner was machining a custom composite material that contained graphite powder. The whole machine was caked in graphite powder mixed with oil and coolant. And the biggest problem was the spindle drive was completely broken. This was primarily the reason the previous owner got rid of the machine. On the plus side, the machine was quite inexpensive (other than the cost to move it), and it fit through my garage door, just barely. I had to take the z-axis servo off to get it through the door!</p>
</div>
<div class="myNotes">
    <p class="top">The first task was to determine if the spindle drive was repairable. The previous owner had it repaired once, and it failed again a few weeks later. They decided to just get rid of the machine, rather that continuing to pay for repairs.</p>
    <p>Someone had previously replaced the capacitors in the spindle drive low voltage power supply. They even used good quality Panasonic capacitors, but they failed to clean up the leaked electrolyte from the original capacitors. The leaked electrolyte left areas of black corrosion on the board, ate away some traces completely, corroded component leads, and had even seeped into some components, leading to the legs falling off when I desoldered them [middle bottom photo]. I removed the components section by section, repaired or replaced the traces, replaced the damaged components, and was able to fully repair the power supply. I load tested the power supply for several hours to ensure it was properly repaired and stable.</p>
    <p>This wasn't the only issue with the spindle drive however...</p>
</div>
<div class="myNotes">
    <p class="top">With the power supply repaired, the drive would power up, but only if all of the power electronics were disconnected from the control board [left image]. Someone had previously left a note saying there was an unknown issue with the power electronics part of the drive. I did some troubleshooting and found that one of the IGBTs was shorted - possibly caused by the damaged power supply. The section of the power supply with the worst damage was the isolated IGBT gate drive voltage regulation. Luckily only one IGBT was shorted, and I was able to source a replacement. [middle images]</p>
    <p>With good IGBTs, the drive would then power up with the power electronics connected, but this still wasn't the end of the issues. It was showing an "Alarm 46" - a lack of 3-phase input power [right image]. Of course I didn't have 3-phase power in my garage. A normal person would just buy a rotary phase converter, but I knew the first thing any VFD does is rectify the incoming 3-phase AC to DC, and some VFDs can run on single phase input so technically a phase converter shouldn't be needed. But this drive was more particular, and wouldn't run from single phase input... at least not without some "persuasion"...</p>
</div>
<div class="myNotes">
    <p class="top">I located the phase detection portion of the control, and drew out a schematic from the PCB. I didn't have a good intuition of how the 3-phase input behaved with the phase detection circuit, so I simulated it in SPICE. From the SPICE simulation, I could see that there were 6 digital signals that fed through opto-couplers to the digital part of the control. 3 signals to indicate which phase was the "most positive", and 3 signals to indicate which phase was the "most negative" at any instant [top two waveforms].</p>
    <p>These looked fairly trivial to re-create with a microcontroller and a few lines of C, and I implemented and tested the output. I disconnected the phase detection circuit from the incoming AC-line connections, and fed the pulses generated by the microcontroller directly into the opto-couplers.</p>
</div>
<div class="myNotes">
    <p class="top">In the upper left screenshot, you can see a logic analyzer trace of the generated pulses, with a 60Hz period, and with the "most negative" pulses phase shifted 60&deg; in relation to the "most positive" pulses, just like in the SPICE simulation. With the microcontroller injecting the "fake" phase pulses into the control, now the drive powered up without any alarms, and was sitting in "ready" state, showing the current motor RPM on the display, which is 0 RPM in the photo above. At this point, technically the machine was fully functional - all axes moved, and the spindle motor worked, but there were still a bunch of other mechanical problems that needed to be addressed.</p>
    <p>I had posted some videos of progress to this point, repairing the power supply, and getting the spindle drive to run on single phase power to YouTube. I received a comment on the single phase video from Alan, someone I would became very good friends with, who had almost the same machine I did. He had the next smaller size machine stuffed into his garage, and was also in the process of getting it running. Alan asked me, "Do you plan to add probing to your machine at some point?", to which my answer was, "Yes, definitely, once I have all the mechanical issues solved and the machine back together". This simple question was what started the whole reverse engineering side of the project... little did I know how deep the rabbit hole would go!</p>
</div>
<div class="myNotes">
    <p class="top">Spindle probing and toolsetting is very desirable to have on a CNC mill. The spindle probing allows the machine to automatically find some reference point on the workpiece to set the work offset, and a toolsetter allows the machine to automatically measure the length and diameter of tools that are in the spindle. Some examples of finding a workpiece reference point (for example an outside or inside corner, or middle of a hole) are shown above.</p>
    <p>Alan mentioned that he had already begun looking into adding probing to his machine too, but there was a problem. The internal memory of the "M3" control that our machines had didn't have enough capacity to load the probing macros.</p>
    <p>With some persuasion from Alan, I was convinced to work on this memory issue before tackling the other mechanical issues on my machine. It sounded like a really fun challenge!</p>
</div>
<div class="myNotes">
    <p class="top">The "larger cousin" of the M3 control, the M300 series, could have enough memory by adding memory expansion boards to slots in the control. As can be seen in the images above, the M300 is physically a larger card cage with more slots, a larger (higher wattage) power supply, and the cards are physically and electrically interchangeable between them, as the M300 uses some of the same cards used in the M3. The firmware however was a bit different, and it was not possible to completely swap an M300 into our existing machines, as some parts of the firmware are customized to the machine, with no easy way to adapt that for the larger control. Notably the PLC (programmable logic controller) ladder logic cannot be swapped between different controls.</p>
    <p>Because the controls are so similar, it would seem like it should be possible to add an M300 memory expansion board to a M3 control. But just physically plugging the board in and having it be recognized was not enough. Memory must be "enabled" in the control in order to be accessible to the user.</p>
</div>
<div class="myNotes">
    <p class="top">Alan had already discovered that a MC471 memory expansion board from a M300 was detected when installed in the M3 [top photo showing a "board inventory" with the MC471 detected], but he could not enable or use the additional memory. To enable additional memory, one must access the hidden "System Parameter" menu with a "secret key sequence", where all of the paid software enabled options can be enabled. Normally this menu is only accessible by "Factory Authorized Technicians" after paying for an option to be added. While not widely known, with enough social engineering the "secret key sequence" was obtained.</p>
    <p>The 'tribal knowledge' of increasing the memory size on a M300 control was to plug the card in, and increase the value of 'prosiz' ("program size") in the hidden menu to enable the additional memory. On the M3 control, this didn't fully work. Increasing the 'prosiz' value from the default of 3 to 4 showed a slight increase in the available memory, but not by anywhere near the size of the memory physically on the MC471 board. Increasing the prosiz setting again to 5 or any value above actually resulted in drastically LESS memory available.</p>
    <p>The "Additional Program Memory Capacity" chart, which was later found in documentation for different machines that used the M300 series controls, also showed that even with a M320, there was a limit to the memory capacity which higher models didn't have. I came to the conclusion that this really seemed like an artificial limitation in the firmware, and the only way to overcome this was to dig into the firmware, find, and fix it.</p>
</div>
<div class="myNotes">
    <p class="top">The CPU used in all of these controls (M3 and M300) was a Motorola MC68020 - a 32 bit processor. To do any analysis of the live system with a logic analyzer, a "real" logic analyzer with more than 64 channels was necessary to monitor both the 32-bit address and data buses, in addition to bus control signals and various Chip Enable or Chip Select (CE/CS) signals throughout the system.</p>
    <p>Previously I had picked up a bunch of HP / Agilent 16700 and 16900 series logic analyzers and an assortment of analyzer boards. These analyzer boards had a manufacturing defect that leads to ALL of the boards failing over time. There were plastic runners glued to the bottom of the boards to prevent scraping surface mount parts off when inserting or removing them from the mainframe chassis. Over time, the glue under the runners absorbs water, becomes corrosive, and eats away at the traces and vias on the boards causing them to fail. This is a well-known issue. Luckily the logic analyzer software has a board self-test which helped narrow down the area of the faults, and ensured the analyzer boards were fully repaired and working. The repair of the boards did require very fine PCB rework, and a lot of trial and error. As an example, the upper left pin of the resistor pack [lower left image] has a slight "green nodule" by the pin. A little scraping revealed that that trace is actually corroded and there is no connection there anymore. Corrosion at the opening of the solder mask at the resistor packs was a common failure on some of the boards.</p>
    <p>One slight issue with the analyzer self-test was discovered when testing 167xx family boards in a 169xx mainframe. The self-test would report incorrect chip reference designators of the failures. In the upper photo, I'm injecting some intentional faults with the purple wire to map the reported chip references to the real ones on a 167xx board. For example, a self-test reported problem on "U37" actually meant a problem on chip "U42" on a 167xx board.</p>
</div>
<div class="myNotes">
    <p class="top">I needed to get a new microscope on a boom stand to be able to work on the logic analyzer boards, as they were too big to fit under my previous microscope. An example of some corroded traces that were under the plastic runners are in the upper right image. Another issue was the stacking connectors [lower right image], which stacks multiple boards together as one larger logical analyzer with more channels. All of the pins in those connectors were corroded as well. The easiest solution would have been to replace the connectors, but they were discontinued and no longer available, so the only solution was to scrape the corrosion off one pin at a time using a sewing needle under the microscope. The lower left image shows 2 analyzer boards passing self test after fixing all of the issues. Of the 5 analyzer boards I had, I was able to fix 4 of them completely, and the 5th had one remaining broken trace. My 16903A mainframe only had 3 slots, and 3 cards were more than enough channels for this project. Identifying the one remaining broken trace on the 5th board will be a future project, when that board is needed.</p>
    <p>Just getting the logic analyzer repaired, tracking down all the needed pod cables, flying leads, stacking cables, and ultimately upgrading the motherboard / RAM / CPU / SSD in the analyzer itself, making the unit much faster and more pleasant to use, took about a month of work.</p>
    <p>Initially I hadn't intended to upgrade the motherboard / RAM / CPU / SSD in the analyzer itself, as I had seen people discussing on the EEVBlog forum, thinking that was a distraction and out of scope from the real project, but after the first weekend of using the logic analyzer with the original much slower CPU, I decided the upgrade would be worthwhile. And indeed, it made a huge difference in the speed and responsiveness of the analyzer software, especially with long captures with a lot of trace data.</p>
</div>
<div class="myNotes">
    <p class="top">I tracked down enough parts to build a minimal M3 system on my desk for reverse engineering. A backplane, CPU board, firmware cartridge, display card, and memory expansion board. Spare power supplies were rather expensive, as they're a common failure item, so instead I used a PC ATX power supply. One complication of doing so was modern ATX supplies provide most current and perform regulation on the 12V rail, whereas this system drew most power from the 5V rail. I had to add a dummy load to the 12V rail of the ATX supply to get it to regulate properly.</p>
    <p>Back when MC68020 systems were being actively developed, wedge boards that plugged between the CPU socket and the actual CPU, and provided breakout connections for a logic analyzer were common. Those wedge boards were impossible to find these days. Initially I looked into making my own wedge board PCB, but the extra long socket pins required that connect both to the original CPU socket, are long enough to pass through a PCB, and provide a pin socket for the CPU to plug into, are also no longer available. Instead, I opted for a low-tech solution - I soldered 0.1" header pins to the back of the CPU socket row by row [lower left image], and plugged the flying leads from the logic analyzer in directly [upper right image]. It's wasn't the most elegant, and took a long time to get all the leads connected correctly, but it worked! No unobtainable wedge board required.</p>
</div>
<div class="myNotes">
    <p class="top">The next task was to extract all of the firmware. Shown here is the main firmware cartridge that plugs into the backplane, but there were also other ROMs with firmware that were of interest on the CPU board as well. I also read the Boot ROM and Option EEPROM on the CPU card. For reference, the main firmware ROM cartridge is 1.5MB. The other cartridge plugged in externally to the firmware cartridge is the PLC ladder logic, and the other parts of firmware that are customized to each machine model.</p>
    <p>Because the main firmware is stored in 3 banks of 4 single-byte wide chips each, the images read from the individual chips in each bank must be interleaved together to provide the full 32-bit wide image, and then the full-width images of each bank concatenated together.
    <p>It was very useful to run some basic checks on the firmware images, such as running 'strings' to see if the firmware image makes sense and has readable ASCII strings in it as would be expected. That also shows that it is the right endianness, not encrypted, etc.</p>
</div>
<div class="myNotes">
    <p class="top">In the top screenshot is the shell script I wrote that used 'srec-cat' and 'cat' to do the interleaving / concatenation to reassemble the full firmware image from the individual chip images. I also automated running strings. I noticed that the firmware image was assembled from a bunch of separate "modules", and each of them has a version string and timestamp, so I automatically extracted those version strings and timestamps of the modules of the firmware as well. I had acquired a few different firmware cartridges with slightly different versions, and it was interesting to compare which parts of the firmware were updated in each release version.</p>
    <p>Lower left is some output of 'strings', showing clearly readable ASCII, indicating successful reassembly of the individual chip images. On the right, the version strings and date stamps of the "modules" in the firmware. Some modules date back to 1992, while others had been updated as late as 1997.</p>
</div>
<div class="myNotes">
    <p class="top">With the logic analyzer connected, and the firmware extracted, it was time to start digging in. But where to even start looking in 1.5MB of code? I figured the easiest place to start was at the beginning, and look at the boot sequence. This was a good place to start if for no other reason than to just to familiarize myself with the whole system, and correlating between logic analyzer traces and the firmware image in Ghidra. It quickly became apparent that when loading memory images into Ghidra for analysis, it was important to set the base address of each image correctly, so that all the address references in the code pointed to the correct places. By monitoring the Chip Select lines of particular peripherals of interest along with the address bus, I was able to figure out the base addresses of the various memory images, and other things of interest on the bus.</p>
    <p>Another small hurdle was figuring out how to get Ghidra to disassemble a raw image. Previously when I had done any work with Ghidra, it was an executable file, either ELF (for Linux), or PE (Windows). Both of these formats have header information that identifies what segments are code vs. data, and Ghidra used that information to automatically start disassembly of the code segments. With a raw binary firmware image, there's no such header information, so Ghidra won't automatically start disassembly as it has no idea what's code and what's not. It took a bit of digging to discover that in such cases, you have to manually start disassembly somewhere that's code, and from there Ghidra will try to follow all references and calls to other code and disassemble as much as it can. This wasn't always sufficient, and some manual poking in multiple places was required to get all of the code disassembled.</p>
</div>
<div class="myNotes">
    <p class="top">This annotated photo is a physical overview of the CPU card, and some areas of interest. I've called out the BootROM, the Option EEPROM, and the connector to the main memory daughter board. There are also 3 ASICs on the board. Of course no documentation or pinouts is available for those custom ASICS, but from a lot of tracing of the PCB, some of them appear to be involved in address and data bus "steering". On the back side of the board, there are a lot of tri-state buss buffer chips. In the larger controls, some models actually use dual CPU cards, so I suspect they're trying to keep the bus on the backplane as available as possible to accommodate both CPUs needing to share it.</p>
    <p>There's also a DSP processor, which I assumed is for doing the real-time motion control coordination, and some dual port SRAM, which I suspected is the bridge between the main CPU and the DSP. With a system as complicated as this, it only makes sense to dig into the details of the parts that are important for the task at hand - expanding the memory, thus not all of the un-related parts were examined in great detail.</p>
    <p>One important detail was I had to cut a trace on the board to be able to disable the cache on the CPU. That allows the whole program flow to be visible on the logic analyzer, as every instruction was fetched from ROM over the bus, rather than some instructions coming from the CPU Cache. This was very important for being able to clearly follow the code execution on the logic analyzer.</p>
</div>
<div class="myNotes">
    <p class="top">This is the main memory daughter board that connects directly to the CPU board. This is normally the only memory board in a M3 control, so expanding this is the goal of this project. This is called a "MC852" board. This contains 8x 32kB, or 256kB total battery backed SRAMS that provide all of the RAM and non-volatile storage in the system. From the 'strings' dump of the firmware, it was apparent that there was also a MC853 board, and a MC854 board. MC853 boards actually exist, but they were only slightly larger, having 12x 32kB, or 384kB total memory capacity. The MC854 being listed in the firmware was very curious, as there was no evidence that a MC854 board was ever produced, or available, but it shows that they were designing with another larger memory board option in mind.</p>
    <p>The ATT7C187P chips in the upper left corner are used as parity bits to extend the main SRAMs. There was some logic on the backside of the board that does the parity computation on writes, and parity checking on reads. If a parity error is detected, a bus fault occurs, and the system halts. There is also a mechanism to disable the parity checking hardware through software control.</p>
    <p>The wires soldered to some of the chips allow easy access to clip logic analyzer leads to the chip select lines.</p>
</div>
<div class="myNotes">
    <p class="top">This is the memory map I was able to reconstruct. I was able to determine the address space base address and extents of all of the important memory regions, as well as some important peripherals such as the dip wwitches, status LEDs, and the UART. With the RAM, I dug down deeper and mapped out different regions of main memory, and what they were used for. You can see that some of the main memory is indeed used as working RAM for the firmware, while a portion of it is treated more as a "filesystem" that holds data that is retained even when the power is off, such as the tool table, the user program space for g-code (the user programs to mill parts), and fixed-cycles (g-code macro routines that are built into the machine).</p>
    <p>The base addresses of the BootROM, the EEPROM, and the main firmware ROM were used when loading those images into Ghidra for analysis. Doing so resolved the vast majority of the previously unresolved function calls and jumps/branches when loading the firmware without the correct base address offsets.</p>
</div>
<div class="myNotes">
    <p class="top">If you've never used Ghidra, or any other disassembler / de-compiler before, this is an overview of what Ghidra provides. On the left pane, there's a hex view of the raw machine code (with addresses), and a disassembly view that shows an assembly representation of the machine code. On the very left side, there's also a visual reference of all conditional and unconditional branches and jumps.</p>
    <p>On the right pane is the decompilation view. Ghidra decompiles the assembly back to C. While the C was a little quicker to read than the assembly, it's still not easy. I've shown a random function that I didn't do any analysis on during the project to show how the function names are generic, all of the variable names are generic and have no intrinsic meaning to the code, and not even all of the variable typing is well defined, but at the very least, Ghidra will determine the type-width. The code itself also tends to be quite challenging to read, with multiple layers of type casting, especially between signed and unsigned types, pointer dereferences, and constants mixed in with the generic variable names. It's very much like reading purposely obfuscated code, but even worse!</p>
    <p>One of the powerful features of Ghidra is as the meaning of variables, functions, or even any random memory addresses are worked out, you can assign meaningful names to them, and those meaningful names start to appear everywhere. Slowly as you work things out and fill in more meaningful names, the code transforms from completely unreadable randomness, to having some logic, and begins making more sense.</p>
</div>
<div class="myNotes">
    <p class="top">I began actually analyzing the boot sequence, with only the CPU board (that contains the Boot ROM and the Option EEPROM) installed in the system. I did some sanity checks between the address and contents of the code I was seeing executing on the logic analyzer to the BootROM image, and everything lined up and made sense. At a certain point, I noticed code was executing from a completely different address, in the RAM area. After doing some analysis, I realized the boot code caches most of the BootROM into RAM, and jumps to that location and continues executing it from there. I suspect they do this because the RAM is 32-bit wide, vs the BootROM which is only 8-bit wide, so much faster (4x) execution from RAM.</p>
    <p>At the end of the capture, I noticed it tried to jump to a different address space again, which turned out to be the main firmware cartridge, but because it wasn't installed, it just halted with a bus error. So it initially boots from the BootROM, caches some of that into RAM, and then jumps to the main firmware image. I took another capture with the firmware cartridge installed, and predictably it jumped to the main firmware and continued execution there. One of the things the main firmware did early on was cache a bunch of the OptionROM contents into RAM as well.</p>
    <p>If any parity error was detected in the SRAM, the system immediately halted with a bus error. Of course if the battery died or if bringing up a brand new system and all the SRAM contains random values, this will happen almost immediately. So how was a new system, or a recovery from battery failure possible?</p>
</div>    
<div class="myNotes">
    <p class="top">To boot a new system, or to recover from a battery failure, there was a special boot mode initiated by setting some dip switches on the CPU board, and rebooting the control. In this mode, the memory parity checking is disabled, and a "clear and initialize RAM" routine is executed. I wondered if this was in some way tied to the option setting that determines the memory size, but it turns out it wasn't. This special boot mode code doesn't check the option setting values at all. All it did was write 0's to all memory locations, and read-back the value. It found the end of memory dynamically, when the readback failed, and if the end address it was able to successfully write to was 'sane', it turned on a green status LED to indicate success, and then the user clears the dip switches and reboots the system in normal mode. Once the memory had been cleared, there wouldn't be any parity errors, and the normal boot code took care of initializing the area of memory necessary for the regular OS to run. It was then up to the user to "format" the portion of memory that's used as a filesystem through the regular UI on the control.</p>
    <p>So while this mode didn't turn out to be fruitful towards the goal, it was a good exercise in getting used to monitoring execution on the logic analyzer, and following through the same code in Ghidra, working out how it worked and what it was doing, as well as gaining experience in how the overall system functioned.</p>
</div>    
<div class="myNotes">
    <p class="top">To interact with the system in normal mode, a keypad and display was absolutely necessary. The custom CRT displays were very expensive, even in "used good" condition, as they're a high-failure part, so in demand to fix other machines still in service. I also didn't want to remove the CRT display from the actual machine, as I didn't have room for it on my desk, and it was very dirty. The next logical solution was to use a scan converter of some sort to be able to convert the non-standard video signal from the machine to a modern LCD monitor.</p>
    <p>In the Retro Computing and Retro Gaming scene, there's a popular open source scan converter that seemed to be the perfect solution. The "RGBtoHDMI" [upper right image]. The RGBtoHDMI can take video signals in a multitude of formats, and using the GPU on a RaspberryPI Zero, along with the bare metal firmware they developed that runs on the Pi, do a "pixel perfect" scaling to any modern display with DVI / HDMI. It also allowed for custom profiles where all of the video settings and timings could be specified for capturing the original signal, even if non-standard.</p>
    <p>It took a bit of measurement of the video signals from the control [lower left image], as well as some trial and error with all of the settings in the RGBtoHDMI to get it working correctly, but in the end, the video scaling to a modern HDMI monitor was indeed "pixel perfect" and looked amazing. The RGBtoHDMI also supports capturing screenshots of the display directly to the SD card on the Pi, and that's how all of the screenshots of the control in this presentation (other than the one on this slide and next slide!) were captured.</p>
</div>    
<div class="myNotes">
    <p class="top">The keyboard was somewhat simpler, as I found a used keyboard for a reasonable price, except for the menu navigation buttons which mount directly below the display. Those were only available as part of used CRT display assemblies. It was pretty easy to trace the pinout of those menu buttons on the original machine, and re-create them with some tactile switches soldered to a piece of proto board, with a lead with standard 0.1" connector to the main keyboard assembly.</p>
    <p>I was then able to interact with the system on my desk fully in normal mode, with a keyboard and display!</p>
</div>
<div class="myNotes">
    <p class="top">To narrow in on the code that actually had the restriction in it, the logical thing to do seemed to be to focus on the 'prosiz' setting, specifically where its value was stored. If that location is known, it would be easy to find all references to it in Ghidra.</p>
    <p>I wrote new values to all of the settings in the hidden System Parameter menu one at a time, while capturing on the logic analyzer, and was able to determine the locations all of those values were stored in. All the addresses of the options can be seen in the right-most screenshot. I determined both the OptionEEPROM location [addresses in middle column of notes] as well as the RAM cached copy of them [address in right column of notes]. I was then able to assign a meaningful label to those memory locations in Ghidra, as well as search for those memory addresses in logic analyzer captures.</p>
    <p>The OptionEEPROM addresses only ever appeared in two places in the logic analyzer captures. When it was read during boot and cached into RAM, and when changing the value in the menu, the new value would get written to both the EEPROM local and the RAM cached location. The RAM cached addresses turned up more matches, both in Ghidra, and in the logic analyzer captures.</p>
</div>
<div class="myNotes">
    <p class="top">Working in the other direction, I also captured the process of formatting the memory on the logic analyzer, and worked backwards through the function call stack from the loop that was actually zeroing the memory word by word, back to the functions that did the setup, and determined the memory ranges that would be formatted. While analyzing all the functions backwards through the call stack, I was filling in as many variable names and function names as I could, and the code started making more and more sense.</p>
    <p>Eventually, my analysis lead me to what I was looking for...</p>
</div>
<div class="myNotes">
    <p class="top">EUREKA!! THE prosiz LIMITATION WAS DISCOVERED! One of the very first things this function did, which I named 'setup_format_user_ram' based on what it was doing, was copy the value of 'prosiz' from the RAM cached location to a local stack variable. Then it checked if the value in the local variable was >4, and if it was, reset the local copy of 'prosiz' to 0. It proceeded to use that local value, as well as local copies of many other option settings, to calculate the memory region sizes and boundaries!</p>
    <p>This certainly felt like an artificial limitation in the firmware to limit the memory size available on the M3 control! Only one way to know for sure, change it and see what happened.</p>
</div>
<div class="myNotes">
    <p class="top">This explains why the 'prosiz' value could be set to 4, but setting it any higher actually resulted in much less memory being available - silently in the code, any value >4 resulted in it effectively being set to '0'.</p>
    <p>This was actually very easy to patch in the firmware, as the only thing that needed to be changed was the literal value of the bounds check. I went into the full firmware image with a hex editor, and changed the single byte value from 4 to an 8. I de-interleaved the modified firmware image back to single-byte images for each ROM chip, and determined which chip image the change ended up in. I UV erased that ROM, and re-flashed it with my patched code.</p>
    <p>Booting the machine with the modified firmware, I was able to confirm that I could indeed now set 'prosiz' values larger than 4, and it would try to format more memory! With prosiz set to 5, it was trying to format more memory than physically existed, and throwing a memory error.</p>
</div>
<div class="myNotes">
    <p class="top">I added the MC471 memory expansion board from the M300 control, and tried formatting the memory again with prosiz set to 5, and this time it succeeded. Monitoring the format on the logic analyzer though, it didn't use all of the memory available on the expansion card. In fact it only used a little over half of the memory available on the MC471.</p>
    <p>It did seamlessly jump from the end address of memory on the CPU daughter board to the base memory address of the MC471, and use both together even though they were at completely different non-contiguous regions in the memory map! The firmware seemed to have built in support to handle this case of multiple memory boards in the system and use them together. But it just wasn't using all of the memory that should have been available.</p>
</div>
<div class="myNotes">
    <p class="top">This is the MC471 board. It contained 8 of the 32kB SRAM chips, the same chips and in the same quantity as the SRAMs on the MC852 memory daughter board directly on the CPU board. The observant will have noticed that there are 24 more footprints for 24 more of the same 32kB SRAMs. Also interesting is the silkscreen labelling the board, where the '1' in 'MC471' is stamped on later, not printed in the silkscreen itself. That's because the board was available in 3 configurations.</p>
    <p>The MC471 had 8x32kB = 256kB, the MC472 populated all 32 chips for a total of 1MB, and the MC474 doubled that again with a second mezzanine board that pluged into the two connectors just below the backplane connectors, that had another 32 chips for a total of 2MB. The larger controls actually support 2 such cards, for a total of 4MB of memory, meaning there should be at least 2MB and maybe 4MB of usable free address space already reserved in the design, as well as the firmware should already have support for addressing at least up to 4MB of memory.</p>
</div>
<div class="myNotes">
    <p class="top">This was a screenshot of the logic analyzer capture while formatting the memory with the MC471 board installed, and 'prosiz' set to 5. The Chip Select lines of both banks of memory on the MC471 were the green and yellow traces. It is obvious that the format touches very little of the memory in the second bank (yellow) compared to the first bank (green) which is fully used.</p>
    <p>The first time the memory was accessed, it is zeroing the entire area that will be used word-by-word. The subsequent sequential accesses of the banks, green then yellow, it was performing other actions part of memory initialization, such as setting up some internal data structures with initial values to ready the memory for use. That portion of the format procedure wasn't interesting after analysis, as it used the same bounds that were calculated for the inital 'zeroing' phase of the formatting.</p>
    <p>On the next slide, I will look in more detail of the transition from the end of the first bank to the start of the second bank (green chip select to yellow chip select), as well as the end address that was accessed in the second bank (the end of the yellow chip select) during the 'zeroing' phase of the format operation.</p>
</div>
<div class="myNotes">
    <p class="top">On top, the first bank to second bank transition (green to yellow Chip Select). This looked perfectly reasonable. The last address accessed in the first bank is 0x81 FFFC, and the first address in the second bank is 4-bytes higher at 0x82 0000. The transition happened at a nice even address that makes sense with the size of the SRAMs, and the base address of the MC471 card.</p>
    <p>On the lower trace, the last address zero'ed in the second bank was at 0x82 9CFC (accessing a 4-byte word up to 0x82 9CFF). This seems like a very odd address to end at. It was not any sort of even power of 2... why was that chosen as the ending address?</p>
</div>
<div class="myNotes">
    <p class="top">Bringing everything together, what does it mean? Why the strange ending address when formatting the memory? Why doesn't it use all of the physical memory available?</p>
    <p>The "Additional Program Memory Capacity" chart shows "600m" for 'prosiz' setting of 5. What does '600m' actually mean? And how does that relate to 236,250 available bytes after formatting? None of these numbers seemed to really make any logical sense!</p>
    <p>And could this be fixed so that all of the physical memory available was used?</p>
</div>
<div class="myNotes">
    <p class="top">So what does '600m' mean? Turns out even in the 90's and later, CNC machine memory was still measured in "meters of paper tape", and 600m literally meant "600 meters of paper tape". The memory sizes that were available as options were sold in nice round "marketing quantities" in "meters of paper tape". The quantities were probably chosen to be competitive with other controls from other companies, and or to match previous generations of controls that offered the same memory size options.</p>
    <p>Because all of the memory sizes available were based on round figures of "meters of paper tape", not based on the actual physical memory in the machine, no matter the memory option that was purchased, some of the physical memory in the machine couldn't ever be used, and was effectively wasted!</p>
    <p>Could this be fixed? Of course! With access to and understanding of the firmware at a low level, it should be possible to change all of this, and be able to use all the physical memory available. Looking a little further down in the 'setup_format_user_ram' function, 'prosiz' was actually an index into a lookup table that determined how much memory will be allocated for programs at each setting of 'prosiz'. Changing the values in the lookup table should change the amount of memory available.</p>
</div>
<div class="myNotes">
    <p class="top">I traced through the code that calculated the memory size, and manually worked through the formula with the values from the lookup table for all values of 'prosiz'. For 'prosiz' 5, by the lookup table, there should have been 263.5kB available, and after formatting, the control showed 236.25kB available. I knew there was some overhead in the internal memory structure for storing the programs, and approximately 10% overhead seemed reasonable.</p>
    <p>This also explained why changing prosiz from 3 to 4 initially showed very little increase in available memory. By the table values, that only allowed 64k of additional memory to be enabled, not accounting for overhead. The increases in memory size from one prosiz setting to the next also got a lot larger with increasing prosiz settings [right-most column in the table].</p>
    <p>Now that I was fairly sure this was the right place to modify the settings, it should be possible to adjust the table values to use all of the memory physically available.</p>
</div>
<div class="myNotes">
    <p class="top">I decided to experiment with the values in the lookup table, as well as some of the other option settings in the System Parameter menu that affected how much memory was available for the program area. I maxed out the other settings which also needed space in the "filesystem" area of memory - the tool table size, the number of tool offsets available, the type of tool offsets, and the number of programs that could be stored.</p>
    <p>I then adjusted the size of the program area in the lookup table to use up the remaining physical memory that was available. Those adjustments, along with a new hardware memory board that Alan had developed while I was working on the firmware side of things, were able to get the available program space up to 556kB! More than enough memory to store all of the probing macros, and still have considerable memory available for user g-code programs as well! SUCCESS!!! Even more program memory could be available if the other settings (tool table size, offsets, etc) weren't all maxed out.</p>
</div>
<div class="myNotes">
    <p class="top">This was the replacement memory board Alan designed while I was working on reverse engineering the firmware. It replaced the original memory daughter board on the CPU board. It had 4 modern Cypress SRAMS on it. The chips on this first 'proof of concept' board don't have parity, but there are pin-compatible variants available from Cypress that have built in parity, eliminating all the discrete logic and separate parity SRAMS on the original memory board.</p>
    <p>Currently without other changes in the firmware, only 1MB of SRAM was addressable on this new board desite it actually having 2MB available. The original MC852 / MC853 used address 0x10 0000 (1MB + 1) as the board detection / ID by reading a few data bits, and the software parity enable / disable by writing a certain data bit. In the firmware, this address could easily be changed to 0x20 0000 (2MB + 1), but that would require an additional address line on the connector to the daughter board. There were a couple of unused pins on the connector that may be additional address lines, but that hasn't been verified yet. The other complication is the Chip Select signals are generated on the CPU board, potentially in one of the ASICs. If the ASIC had a fixed memory address range that it asserts the Chip Selects that go to the memory board, this could also be a problem as there would be no way to change that. So a 2MB memory board might be possible, or perhaps even 3MB, depending on address lines and ASIC logic. 4MB wouldn't be possible, as there was something else that I suspected was the hardware watchdog at address 0x38 0003 in the memory map.</p>
</div>
<div class="myNotes">
    <p class="top">The newly developed memory board was setup to ID as the previously never released MC854 board. Like the 'prosiz' setting, the board ID value read back from the hardware is used as an index into a lookup table that defines the memory size of the board, probably to know when to jump to the external memory board base address to use both memory regions together seamlessly, as discussed in a previous slide.  Using the previously unused board ID, and setting the appropriate values for this board in the lookup table for the previously unreleased board, allows the same firmware image to work with all possible boards. The original MC852 / Mc853, as well as the newly developed "MC854".</p>
    <p>In the future I do plan to look into the possibility of relocating the board ID / control address, and seeing if it's possible with the existing hardware to address 2MB of SRAM. That would be a monumental upgrade for a machine that originally only had 256kB.</p>
</div>
<div class="myNotes">
    <p class="top">This is a summary from my notes of all of the changes that I made to the firmware throughout the whole project, right up to being able to use 1MB of SRAM on the new MC854 board. There were also some other changes required to some memory region bounds checking that I didn't go into detail of in this presentation, the last 5 lines of notes. I've hidden the addresses of the changes for the purpose of posting this presentation publicly, to protect the great deal of effort that went into this project.</p>
    <p>For every change, I made note of the change address, including the base offset of firmware memory, as well as the offset in the raw firmware image file without the base offset, in both hex and decimal. The hex editor I was using to modify the firmware image only showed offset addresses into the file in decimal for some reason.</p>
</div>
<div class="myNotes">
    <p class="top">Another future option for adding more memory would be to build a modern MC471 replacement that plugs into the bus, rather than being limited to the CPU board memory card connector. The backplane and all the cards are based on VME bus standards, which defines the pinout of the top bus connector, but leaves the bottom connector pinout as user defined. The right-most 2 slots on the M3, and most of the right-most slots in the larger backplanes have a separate bus on the lower connector that doesn't connect to the CPU board, meaning only certain slots in the M300 controls, and NO available slots in the M3 control have the full 32-bit bus available. On my machine, I also have 2 I/O boards in the right slots anyway, so there are no open slots at all to plug a memory expansion board into.</p>
    <p>But, all of the enclosures in both the M3 and M300 have an externally accessible top bus connector on the left side of the chassis (see the yellow arrow in the left picture above). It should be possible to create a memory expansion board that uses that connector and sits on the side of the chassis. The downside would be it would only have a 16-bit data path, so would be twice as slow, as 2 bus reads would be required to fetch each 32 bit value. I don't think this would be an issue for program space, that's only storing user g-code, that is pre-loaded into a read-ahead buffer before it's interpreted by the motion controller to actually drive the motors. This is another future possibility I would like to look into.</p>
</div>
<div class="myNotes">
    <p class="top">A summary list of all the major sub-projects that were completed along the way to achieving the goal of expanding the program memory to have enough space to load the probing macros into this machine.</p>
    <p>My original goal of getting a CNC machine was to make parts for other projects, and I didn't anticipate the machine becoming such a huge project of its own. I very much didn't anticipate any of the reverse engineering work that went into this at all, but I thuroughly enjoyed working on all of it. It is immensely rewarding to see all the work pay off in the end and achieving the goal that was set out at the beginning. I learned a LOT about reverse engineering an embedded system, and especially just how much work it is to actually follow through with such a large multi-faceted project! I had done a few small software reverse engineering projects in the past, but nothing even close to the scale of this project.</p>
</div>
<div class="myNotes">
    <p class="top">The following bonus slides are a brief look at the other aspects of the project, mostly the mechanical side, as well as some unexpected other projects that came up, that are very similar, but took focus away from the mill project in the short term.</p>
</div>
<div class="myNotes">
    <p class="top">Why did I get a CNC mill? I wanted to be able to make parts for other projects, like this tank robot platform I picked up recently. I didn't anticipate the CNC was going to become such a huge project in and of itself. It was supposed to be a tool to help other projects, but in the end I enjoyed the electrical diagnosis and repair, the mechanical repairs, and especially the reverse engineering side, and leaned many things along the way too.</p>
</div>
<div class="myNotes">
    <p class="top">Very early pictures from just after the machine was moved in. It is a little more visible how dirty and covered in graphite powder it was in these photos.</p>
</div>
<div class="myNotes">
    <p class="top">Some parts cleaned, but lots more to go!</p>
</div>
<div class="myNotes">
    <p class="top">Removing the spindle motor to replace bad bearings. Motor weighs far too much to lift by hand, so the trusty engine hoist to the rescue.</p>
</div>
<div class="myNotes">
    <p class="top">Size of spindle motor shaft compared to my hand. A 15 HP motor has a large output shaft! I also had the rotor balanced by a motor shop while it was apart.</p>
</div>
<div class="myNotes">
    <p class="top">Cleaning the air system, way oil lubrication pump, and the toolchanger.</p>
</div>
<div class="myNotes">
    <p class="top">Removed the Y-axis way covers - YIKES what a mess of chips, way oil and cutting coolant mixed with graphite powder!</p>
</div>
<div class="myNotes">
    <p class="top">I Discovered that all of the lubrication passages on the ways were plugged with graphite. Both the table and saddle have to come off to clean it all out. Having way oil lubricating the ways of the machine is important to prevent wear and damage to the precision sliding surfaces.</p>
</div>
<div class="myNotes">
    <p class="top">The table is removed. Still a huge mess behind the Y-axis. I decided that since everything had to come apart anyway, pressure washing what could be rolled outside would be a lot faster than cleaning by hand, as I had been doing up to that point.</p>
</div>
<div class="myNotes">
    <p class="top">Saddle removed, and pressure washed. Y-axis ways on base casting cleaned up. Found damaged Turcite on both table and saddle that needed to be replaced. The Turcite is the blue matterial in the middle two photos that makes up the other side of the sliding surfaces. All of the ways on this machine are Turcite sliding on hardened cast iron. Turcite is a special formulation of Teflon with impregnated brass that's specially designed for low friction, high wear resistance sliding way surfaces in machine tools, and similar applications.</p>
</div>
<div class="myNotes">
    <p class="top">Finished cleaning Y-axis ways. Epoxying replacement Turcite to saddle. The ways, and ballscrew are covered in aluminum foil to prevent getting epoxy on them. The only precision surface I had to clamp the Turcite in place while the epoxy was curing was the machine ways itself, so the saddle was clamped to the machine ways after applying the epoxy.</p>
</div>
<div class="myNotes">
    <p class="top">Removing the saddle again after epoxy cured on replacement Turcite. Moving the machine to a different place in the garage so I could put the Z-axis motor back on and have it clear the garage door. Removing the rest of the enclosure for cleaning, and to have easier access to remove / replace saddle and table for doing Turcite replacement, and paint.</p>
</div>
<div class="myNotes">
    <p class="top">Machined moved to new spot. Z-axis motor back on, clearing the garage door. Getting ready to remove the spindle cartridge from the head casting, and the head casting from the machine for cleaning.</p>
</div>
<div class="myNotes">
    <p class="top">Head casting removed, and pressure washed. Cleaning remaining gunk from behind head casting on Z-axis</p>
</div>
<div class="myNotes">
    <p class="top">Head casting re-installed on Z-axis. All cleaning is now fully done.</p>
</div>
<div class="myNotes">
    <p class="top">A new project arrives. A free CNC lathe someone gave me because no one else could repair it. Like the mill, the spindle drive was damaged. Mechanically the machine is in excellent shape, so this on only requires light cleaning, and electronics repair, no major mechanical repair or disassembly like the mill.</p>
</div>
<div class="myNotes">
    <p class="top">Some electrical reverse engineering while fixing the lathe spindle drive. Of course no schematics are available, so they need to be drawn from the PCB manually if needed. It looks like an IGBT shorted, and blew up 2 of the IGBT gate drivers on the control board. Someone had attempted to repair it, but missed some critical parts that were still damaged, so it would not run.</p>
</div>
<div class="myNotes">
    <p class="top">Figuring out how to convince the lathe to run on single-phase power. This phase detection circut is mostly analog - a good refresher of analog circuits looking at this and figuring out how it works, and how to bypass it! The theory of operation is very similar to, but not exactly the same as the mill spindle drive.</p>
</div>
<div class="myNotes">
    <p class="top">More SPICE simulations of phase detection circuitry in the lathe spindle drive to better understand how it works.</p>
</div>
<div class="myNotes">
    <p class="top">Lathe up and running on single phase power with spindle drive repaired. Cutting first chips. Then a hydraulic leak appeared, and I had to replace a pressure gauge and some hydraulic lines. Because lathe is Japanese, fun times with incompatible NPT (National Pipe Thread) vs BSPP (British Standard Parallel Pipe-thread) hydraulic fittings and pressure gauges! <a href="https://www.youtube.com/watch?v=X7LXRExTaXo" target="_blank">A video of the lathe actually making the first parts!</a></p>
</div>
<div class="myNotes">
    <p class="top">Converting lathe spindle drive to use resistive braking rather than regenerative braking. Probing HV 3-phase signals with differential probes. Braking is almost working. Goin to require more adjustments to the 3-phase detection circuit.</p>
</div>
<div class="myNotes">
    <p class="top">Yet another free machine someone gave me - this time a Wire EDM. After making room to move it in, which was no small task, it's on the back burner until the mill is up and running.</p>
</div>
</div>
</div>

<script>
var slideIndex = 1;
showSlides(slideIndex);

function plusSlides(n) {
  showSlides(slideIndex += n);
}

function currentSlide(n) {
  showSlides(slideIndex = n);
}

function showSlides(n) {
  var i;
  var slides = document.getElementsByClassName("mySlides");
  var indexes = document.getElementsByClassName("myIndex");
  var notes = document.getElementsByClassName("myNotes");
  var notesContainer = document.getElementsByClassName("notes-container");
  if (n > slides.length) {slideIndex = 1}    
  if (n < 1) {slideIndex = slides.length}
  var pad_prevslide=String(slideIndex-1).padStart(2,'0');
  var pad_currslide=String(slideIndex).padStart(2,'0');
  var pad_nextslide=String(slideIndex+1).padStart(2, '0');
  for (i = 0; i < slides.length; i++) {
      slides[i].style.display = "none";  
  }
  for (i = 0; i < indexes.length; i++) {
      indexes[i].className = indexes[i].className.replace(" active", "");
  }
  for (i = 0; i < notes.length; i++) {
      notes[i].style.display = "none";
  }
  var currSlideImg = document.getElementById("slide"+pad_currslide);
  if (currSlideImg) {
    if (!currSlideImg.getAttribute("data")) {
        console.log("loading current slide image slide"+pad_currslide+".svg");
        currSlideImg.setAttribute('data', "slides/slide"+pad_currslide+".svg"); 
        currSlideImg.setAttribute("type", "image/svg+xml");
    }
  }
  slides[slideIndex-1].style.display = "block";  
  if (slideIndex-1 < notes.length) {notes[slideIndex-1].style.display = "block"}
  if (slideIndex-1 < indexes.length) {indexes[slideIndex-1].className += " active"}
  indexes[slideIndex-1].scrollIntoView({ behavior: 'smooth', block: 'center'});
  notesContainer[0].scrollTo(0, 0);
  
  /*pre-load next slide lazily*/
  var nextSlideImg = document.getElementById("slide"+pad_nextslide);
  if (nextSlideImg) {
    if (!nextSlideImg.getAttribute("data")) {
        console.log("loading next slide image slide"+pad_nextslide+".svg");
        nextSlideImg.setAttribute('data', "slides/slide"+pad_nextslide+".svg"); 
        nextSlideImg.setAttribute("type", "image/svg+xml");
    }
  }
  /*pre-load previous slide lazily, incase jumped to random new slide*/
  var prevSlideImg = document.getElementById("slide"+pad_prevslide);
  if (prevSlideImg) {
    if (!prevSlideImg.getAttribute("data")) {
        console.log("loading previous slide image slide"+pad_prevslide+".svg");
        prevSlideImg.setAttribute('data', "slides/slide"+pad_prevslide+".svg"); 
        prevSlideImg.setAttribute("type", "image/svg+xml");
    }
  }
}

document.addEventListener('keydown', (event) => {
  // Prevent default browser behavior for arrow keys (e.g., scrolling)
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
    event.preventDefault();
  }

  switch (event.key) {
    case 'ArrowUp':
      //console.log('Up arrow key pressed!');
      document.getElementById("notes-container").scrollBy({top: -200, behavior: "smooth"});
      // Add your desired logic for the Up arrow key here
      break;
    case 'ArrowDown':
      //console.log('Down arrow key pressed!');
      document.getElementById("notes-container").scrollBy({top: 200, behavior: "smooth"});
      // Add your desired logic for the Down arrow key here
      break;
    case 'ArrowLeft':
      //console.log('Left arrow key pressed!');
      // Add your desired logic for the Left arrow key here
      plusSlides(-1)
      break;
    case 'ArrowRight':
      //console.log('Right arrow key pressed!');
      // Add your desired logic for the Right arrow key here
      plusSlides(1)
      break;
    default:
      // Other keys can be handled here if needed
      break;
  }
});
</script>

</body>
</html> 
